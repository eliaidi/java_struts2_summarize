1. Action 实现 ModelDriven 接口后的流程：
	
	<1>. 先会执行 ModelDrivenInterceptor 的 interceptor 方法
	
		public String intercept(ActionInvocation invocation) throws Exception {
		  	// 获取 Action 对象： EmployeeAction 对象，此时该 Action 已经实现了 ModelDriven 接口
		  	// public class EmployeeAction implements RequestAware, ModelDriven<Employee>
	        Object action = invocation.getAction();
	
			// 判断 action 是否是 ModelDriven 的实例
	        if (action instanceof ModelDriven) {
	        	// 强制转换为 ModelDriven 类型
	            ModelDriven modelDriven = (ModelDriven) action;
	            
	            // 获取值栈
	            ValueStack stack = invocation.getStack();
	            
	            // 调用 ModelDriven 接口的 getModel() 方法
	            // 即调用 EmployeeAction 的 getModel() 方法
	            /*
	            	public Employee getModel() {

						employee = new Employee();
						
						return employee;
					}
	            */
	            Object model = modelDriven.getModel();
	            if (model !=  null) {
	            	// 把 getModel() 方法的返回值压入到值栈的栈顶，实际压入的是 EmployeeAction 的 employee 成员变量
	            	stack.push(model);
	            }
	            if (refreshModelBeforeResult) {
	                invocation.addPreResultListener(new RefreshModelBeforeResult(modelDriven, model));
	            }
	        }
	        return invocation.invoke();
	    }
	
	<2>. 再执行 ParametersInterceptor 的 interceptor 方法： 把请求参数的值赋给栈顶对象对应的属性，
	若栈顶对象没有对应的属性，则查询值栈中下一个对象对应的属性。
		
		会将表单字段映射到值栈栈顶的各个属性中
	
	<3>. 需要注意的部分：
	
		getModel() 方法不能提供以下的实现
			public Employee getModel() {
				return new Employee();
			}
	
		因为以上用法的确会返回一个 Employee 对象到值栈的栈顶，但是当前 Action 中的 employee 成员变量 却是 null
		

2. 使用 paramsPrepareParamsStack 拦截器栈后的运行

	<1>. paramsPrepareParamsStack 和 Struts2 中默认的 defaultStack 都是拦截器栈，
		struts-default 默认使用的是 defaultStack
	
	<2>. 可以在 Struts 配置文件中通过以下方式修改使用默认的拦截器栈
		<!-- 配置使用 paramsPrepareParamsStack 作为默认的拦截器栈 -->
    	<default-interceptor-ref name="paramsPrepareParamsStack"></default-interceptor-ref>
   	
   	<3>. paramsPrepareParamsStack 拦截器在于执行的顺序
   	
   		params --> modelDriven --> params
   		所以可以先把请求参数赋给 Action 对应的属性，再根据 Action 的那个属性值决定压到值栈栈顶的对象，
   		最后再为栈顶对象的属性赋初值
   		
   			对 Edit 操作而言：
   				① 先为 EmployeeAction 的employeeId 赋值
   				② 根据 employeeId 从数据库中加载对应的对象，并放入到值栈的栈顶
   				③ 再为栈顶对象的 employeeId 赋值(实际上此时 employeeId 属性值已经存在)
   				④ 把栈顶对象的属性回显在表单中
   				
   	<4>. 关于回显：
   		Struts2 表单标签会从值栈中获取对应的属性值进行回显
   		
   	<5>. 存在的问题：
   		以下为 getModel 方法：
   		
	   		public Employee getModel() {
				if(employeeId == null)
					employee = new Employee();
				else
					employee = dao.get(employeeId);
				
				return employee;
			}
			
			① 在执行删除的时候， employeeId 不为 null，但是 getModel 方法却从数据库中加载了一个对象
				此时不该加载
			② 在执行查询全部信息时，也 new 创建了一个 employee 对象，此时浪费！

	<6>. 解决方案：
		使用 PrepareInterceptor 和 Preparable 接口		
		
	<7>. 关于 PrepareInterceptor 拦截器
	
		// 以下为分析后得到的结论
		
			① 若 Action 实现了 Perparable 接口，则 Struts2 将尝试 执行 prepare[ActionMethodName]([]中的为目标方法名) 方法，
			② 若 prepare[ActionMethodName] 方法不存在，则将尝试执行 prepareDo[ActionMethodName] 方法，
			③ 若不存在，就都不执行
			
			④ 若 PrepareInterceptor 的 alwaysInvokePrepare 属性为 false时，
			则 Struts2 将不会调用实现了 Perparable 接口的 Action 的 prepare 方法
		
		// 能解决<5> 中存在问题的方案如下
		
			① 可以为每一个 ActionMethodName 准备 prepare[ActionMethodName] 方法，而抛弃掉原来的 prepare 方法
			② 将 Perparable 接口的
	
		--------- 以下为源代码的解析部分 ----------
		
		public String doIntercept(ActionInvocation invocation) throws Exception {
			// 获取 Action 实例
	        Object action = invocation.getAction();
	
			// 判断 Action 是否实现了 Preparable 接口
	        if (action instanceof Preparable) {
	            try {
	                String[] prefixes;
	                
	                // 根据当前拦截器的 firstCallPrepareDo(默认为 false) 属性确定前缀数组 prefixes
	                if (firstCallPrepareDo) {
	                    prefixes = new String[] {ALT_PREPARE_PREFIX, PREPARE_PREFIX};
	                } else {
	                    prefixes = new String[] {PREPARE_PREFIX, ALT_PREPARE_PREFIX};
	                }
	                
	                // 若 firstCallPrepareDo 为 false， 则 prefixes： prepare, prepareDo
	                // 调用前缀方法
	                PrefixMethodInvocationUtil.invokePrefixMethod(invocation, prefixes);
	            }
	            catch (InvocationTargetException e) {

	                Throwable cause = e.getCause();
	                if (cause instanceof Exception) {
	                    throw (Exception) cause;
	                } else if(cause instanceof Error) {
	                    throw (Error) cause;
	                } else {
	                    throw e;
	                }
	            }
	
				// 根据当前拦截器的 alwaysInvokePrepare(默认是true) 属性决定是否调用 Action 的 prepare 方法
	            if (alwaysInvokePrepare) {
	                ((Preparable) action).prepare();
	            }
	        }
	
	        return invocation.invoke();
	    }
	    
	    
	    // 上面方法中调用的前缀方法   PrefixMethodInvocationUtil.invokePrefixMethod(invocation, prefixes);
	    // 前缀方法如下
	    public static void invokePrefixMethod(ActionInvocation actionInvocation, String[] prefixes) throws InvocationTargetException, IllegalAccessException {
			// 获取 Action 实例
			Object action = actionInvocation.getAction();
			
			// 获取要调用的 Action 方法的名字(例子: update)
			String methodName = actionInvocation.getProxy().getMethod();
			
			// 如果方法为null，则方法名为 execute
			if (methodName == null) {
				// if null returns (possible according to the docs), use the default execute 
		        methodName = DEFAULT_INVOCATION_METHODNAME;
			}
			
			// 获取前缀方法
			Method method = getPrefixedMethod(prefixes, methodName, action);
			
			// 若方法不为 null，则通过反射调用前缀方法
			if (method != null) {
				method.invoke(action, new Object[0]);
			}
		}
		
		// 调用前缀方法：PrefixMethodInvocationUtil.getPrefixedMethod 方法
		public static Method getPrefixedMethod(String[] prefixes, String methodName, Object action) {
			assert(prefixes != null);
			
			// 把方法的首字母变成大写
			String capitalizedMethodName = capitalizeMethodName(methodName);
			
			// 遍历前缀数组
	        for (String prefixe : prefixes) {
	        
	        	// 通过拼接的方式，得到前缀方法名： 第一次 prepareUpdate，第二次 prepareDoUpdate
	            String prefixedMethodName = prefixe + capitalizedMethodName;
	            try {
	            
	            	// 利用反射从 action 中获取对应的方法，若有则直接返回，并结束循环
	                return action.getClass().getMethod(prefixedMethodName, EMPTY_CLASS_ARRAY);
	            }
	            catch (NoSuchMethodException e) {
	                // hmm -- OK, try next prefix
	                if (LOG.isDebugEnabled()) {
	                    LOG.debug("cannot find method [#0] in action [#1]", prefixedMethodName, action.toString());
	                }
	            }
	        }
			return null;
		}
   			
   			
   			
   			
   		
	